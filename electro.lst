CCS PCH C Compiler, Version 5.025, 36897               17-mai-22 08:53

               Filename:   C:\Users\hakiz\OneDrive\Bureau\Haute Ecole Ephec\Bloc 2\Electronique Analogique\ProjetElectro\Electronique-digital-II\electro.lst

               ROM used:   1692 bytes (5%)
                           Largest free fragment is 31072
               RAM used:   49 (3%) at main() level
                           62 (4%) worst case
               Stack used: 2 locations (1 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   040C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00C6
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <electro.h> 
.................... #include <18F458.h> 
.................... //////////// Standard Header file for the PIC18F458 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F458 
*
0106:  DATA 64,69
0108:  DATA 73,74
010A:  DATA 61,6E
010C:  DATA 63,65
010E:  DATA 20,3A
0110:  DATA 20,25
0112:  DATA 6C,64
0114:  DATA 20,0A
0116:  DATA 00,00
0118:  MOVLW  8E
011A:  MOVWF  00
011C:  MOVFF  30,01
0120:  MOVFF  2F,02
0124:  CLRF   03
0126:  MOVF   01,F
0128:  BNZ   013C
012A:  MOVFF  02,01
012E:  CLRF   02
0130:  MOVLW  08
0132:  SUBWF  00,F
0134:  MOVF   01,F
0136:  BNZ   013C
0138:  CLRF   00
013A:  BRA    014C
013C:  BCF    FD8.0
013E:  BTFSC  01.7
0140:  BRA    014A
0142:  RLCF   02,F
0144:  RLCF   01,F
0146:  DECF   00,F
0148:  BRA    013C
014A:  BCF    01.7
014C:  GOTO   04B2 (RETURN)
0150:  MOVF   2F,W
0152:  BTFSC  FD8.2
0154:  BRA    0238
0156:  MOVWF  00
0158:  MOVF   33,W
015A:  BTFSC  FD8.2
015C:  BRA    0238
015E:  ADDWF  00,F
0160:  BNC   016A
0162:  MOVLW  81
0164:  ADDWF  00,F
0166:  BC    0238
0168:  BRA    0172
016A:  MOVLW  7F
016C:  SUBWF  00,F
016E:  BNC   0238
0170:  BZ    0238
0172:  MOVFF  30,37
0176:  MOVF   34,W
0178:  XORWF  37,F
017A:  BSF    30.7
017C:  BSF    34.7
017E:  MOVF   32,W
0180:  MULWF  36
0182:  MOVFF  FF4,39
0186:  MOVF   31,W
0188:  MULWF  35
018A:  MOVFF  FF4,03
018E:  MOVFF  FF3,38
0192:  MULWF  36
0194:  MOVF   FF3,W
0196:  ADDWF  39,F
0198:  MOVF   FF4,W
019A:  ADDWFC 38,F
019C:  MOVLW  00
019E:  ADDWFC 03,F
01A0:  MOVF   32,W
01A2:  MULWF  35
01A4:  MOVF   FF3,W
01A6:  ADDWF  39,F
01A8:  MOVF   FF4,W
01AA:  ADDWFC 38,F
01AC:  MOVLW  00
01AE:  CLRF   02
01B0:  ADDWFC 03,F
01B2:  ADDWFC 02,F
01B4:  MOVF   30,W
01B6:  MULWF  36
01B8:  MOVF   FF3,W
01BA:  ADDWF  38,F
01BC:  MOVF   FF4,W
01BE:  ADDWFC 03,F
01C0:  MOVLW  00
01C2:  ADDWFC 02,F
01C4:  MOVF   30,W
01C6:  MULWF  35
01C8:  MOVF   FF3,W
01CA:  ADDWF  03,F
01CC:  MOVF   FF4,W
01CE:  ADDWFC 02,F
01D0:  MOVLW  00
01D2:  CLRF   01
01D4:  ADDWFC 01,F
01D6:  MOVF   32,W
01D8:  MULWF  34
01DA:  MOVF   FF3,W
01DC:  ADDWF  38,F
01DE:  MOVF   FF4,W
01E0:  ADDWFC 03,F
01E2:  MOVLW  00
01E4:  ADDWFC 02,F
01E6:  ADDWFC 01,F
01E8:  MOVF   31,W
01EA:  MULWF  34
01EC:  MOVF   FF3,W
01EE:  ADDWF  03,F
01F0:  MOVF   FF4,W
01F2:  ADDWFC 02,F
01F4:  MOVLW  00
01F6:  ADDWFC 01,F
01F8:  MOVF   30,W
01FA:  MULWF  34
01FC:  MOVF   FF3,W
01FE:  ADDWF  02,F
0200:  MOVF   FF4,W
0202:  ADDWFC 01,F
0204:  INCF   00,F
0206:  BTFSC  01.7
0208:  BRA    0214
020A:  RLCF   38,F
020C:  RLCF   03,F
020E:  RLCF   02,F
0210:  RLCF   01,F
0212:  DECF   00,F
0214:  MOVLW  00
0216:  BTFSS  38.7
0218:  BRA    022E
021A:  INCF   03,F
021C:  ADDWFC 02,F
021E:  ADDWFC 01,F
0220:  MOVF   01,W
0222:  BNZ   022E
0224:  MOVF   02,W
0226:  BNZ   022E
0228:  MOVF   03,W
022A:  BNZ   022E
022C:  INCF   00,F
022E:  BTFSC  37.7
0230:  BSF    01.7
0232:  BTFSS  37.7
0234:  BCF    01.7
0236:  BRA    0240
0238:  CLRF   00
023A:  CLRF   01
023C:  CLRF   02
023E:  CLRF   03
0240:  GOTO   04D4 (RETURN)
0244:  MOVLW  8E
0246:  MOVWF  00
0248:  MOVF   2F,W
024A:  SUBWF  00,F
024C:  MOVFF  30,02
0250:  MOVFF  31,01
0254:  BSF    02.7
0256:  MOVF   00,F
0258:  BZ    026C
025A:  BCF    FD8.0
025C:  MOVF   02,F
025E:  BNZ   0264
0260:  MOVF   01,F
0262:  BZ    026C
0264:  RRCF   02,F
0266:  RRCF   01,F
0268:  DECFSZ 00,F
026A:  BRA    025A
026C:  BTFSS  30.7
026E:  BRA    027A
0270:  COMF   01,F
0272:  COMF   02,F
0274:  INCF   01,F
0276:  BTFSC  FD8.2
0278:  INCF   02,F
027A:  GOTO   04E6 (RETURN)
027E:  TBLRD*+
0280:  MOVFF  FF6,30
0284:  MOVFF  FF7,31
0288:  MOVF   FF5,W
028A:  BTFSS  F9E.4
028C:  BRA    028A
028E:  MOVWF  FAD
0290:  MOVFF  30,FF6
0294:  MOVFF  31,FF7
0298:  DECFSZ 2F,F
029A:  BRA    027E
029C:  GOTO   04FC (RETURN)
02A0:  MOVFF  FEA,37
02A4:  MOVFF  FE9,36
02A8:  BTFSS  30.7
02AA:  BRA    02BC
02AC:  BSF    36.7
02AE:  BTFSS  36.4
02B0:  INCF   36,F
02B2:  COMF   2F,F
02B4:  COMF   30,F
02B6:  INCF   2F,F
02B8:  BTFSC  FD8.2
02BA:  INCF   30,F
02BC:  SWAPF  30,W
02BE:  IORLW  F0
02C0:  MOVWF  32
02C2:  ADDWF  32,F
02C4:  ADDLW  E2
02C6:  MOVWF  33
02C8:  ADDLW  32
02CA:  MOVWF  35
02CC:  MOVF   30,W
02CE:  ANDLW  0F
02D0:  ADDWF  33,F
02D2:  ADDWF  33,F
02D4:  ADDWF  35,F
02D6:  ADDLW  E9
02D8:  MOVWF  34
02DA:  ADDWF  34,F
02DC:  ADDWF  34,F
02DE:  SWAPF  2F,W
02E0:  ANDLW  0F
02E2:  ADDWF  34,F
02E4:  ADDWF  35,F
02E6:  RLCF   34,F
02E8:  RLCF   35,F
02EA:  COMF   35,F
02EC:  RLCF   35,F
02EE:  MOVF   2F,W
02F0:  ANDLW  0F
02F2:  ADDWF  35,F
02F4:  RLCF   32,F
02F6:  MOVLW  07
02F8:  MOVWF  31
02FA:  MOVLW  0A
02FC:  DECF   34,F
02FE:  ADDWF  35,F
0300:  BNC   02FC
0302:  DECF   33,F
0304:  ADDWF  34,F
0306:  BNC   0302
0308:  DECF   32,F
030A:  ADDWF  33,F
030C:  BNC   0308
030E:  DECF   31,F
0310:  ADDWF  32,F
0312:  BNC   030E
0314:  CLRF   FEA
0316:  MOVLW  31
0318:  MOVWF  FE9
031A:  MOVLW  07
031C:  ANDWF  36,W
031E:  BCF    36.6
0320:  MOVF   FED,F
0322:  ANDWF  36,W
0324:  BNZ   0334
0326:  BTFSC  36.4
0328:  MOVF   FEE,F
032A:  BTFSC  36.4
032C:  BRA    0334
032E:  MOVLW  20
0330:  MOVWF  00
0332:  BRA    0374
0334:  ADDWF  FE9,F
0336:  MOVLW  00
0338:  ADDWFC FEA,F
033A:  MOVF   FE9,W
033C:  SUBLW  35
033E:  BNZ   0346
0340:  MOVF   FEA,F
0342:  BNZ   0346
0344:  BSF    36.6
0346:  MOVF   FEF,W
0348:  MOVWF  00
034A:  BNZ   035C
034C:  BTFSC  36.6
034E:  BRA    035C
0350:  BTFSC  36.4
0352:  BRA    037C
0354:  BTFSC  36.3
0356:  BRA    035C
0358:  MOVLW  20
035A:  BRA    0372
035C:  BTFSS  36.7
035E:  BRA    036C
0360:  MOVLW  2D
0362:  MOVWF  00
0364:  MOVF   FED,W
0366:  BCF    36.6
0368:  BCF    36.7
036A:  BRA    0374
036C:  BSF    36.3
036E:  BCF    36.4
0370:  MOVLW  30
0372:  ADDWF  00,F
0374:  MOVF   00,W
0376:  BTFSS  F9E.4
0378:  BRA    0376
037A:  MOVWF  FAD
037C:  MOVF   FEE,W
037E:  BTFSS  36.6
0380:  BRA    033A
0382:  GOTO   050A (RETURN)
*
03AC:  CLRF   01
03AE:  CLRF   02
03B0:  CLRF   00
03B2:  CLRF   03
03B4:  MOVF   34,W
03B6:  BNZ   03BC
03B8:  MOVF   33,W
03BA:  BZ    03EC
03BC:  MOVLW  10
03BE:  MOVWF  35
03C0:  BCF    FD8.0
03C2:  RLCF   31,F
03C4:  RLCF   32,F
03C6:  RLCF   00,F
03C8:  RLCF   03,F
03CA:  MOVF   34,W
03CC:  SUBWF  03,W
03CE:  BNZ   03D4
03D0:  MOVF   33,W
03D2:  SUBWF  00,W
03D4:  BNC   03E4
03D6:  MOVF   33,W
03D8:  SUBWF  00,F
03DA:  BTFSS  FD8.0
03DC:  DECF   03,F
03DE:  MOVF   34,W
03E0:  SUBWF  03,F
03E2:  BSF    FD8.0
03E4:  RLCF   01,F
03E6:  RLCF   02,F
03E8:  DECFSZ 35,F
03EA:  BRA    03C0
03EC:  RETURN 0
03EE:  MOVF   2F,W
03F0:  MULWF  31
03F2:  MOVFF  FF3,01
03F6:  MOVFF  FF4,00
03FA:  MULWF  32
03FC:  MOVF   FF3,W
03FE:  ADDWF  00,F
0400:  MOVF   30,W
0402:  MULWF  31
0404:  MOVF   FF3,W
0406:  ADDWFC 00,W
0408:  MOVWF  02
040A:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
0386:  CLRF   FEA
0388:  MOVLW  2F
038A:  MOVWF  FE9
038C:  MOVF   FEF,W
038E:  BZ    03AA
0390:  MOVLW  06
0392:  MOVWF  01
0394:  CLRF   00
0396:  DECFSZ 00,F
0398:  BRA    0396
039A:  DECFSZ 01,F
039C:  BRA    0394
039E:  MOVLW  7B
03A0:  MOVWF  00
03A2:  DECFSZ 00,F
03A4:  BRA    03A2
03A6:  DECFSZ FEF,F
03A8:  BRA    0390
03AA:  RETURN 0
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................   
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, ERRORS) 
*
00AE:  BTFSS  F9E.5
00B0:  BRA    00AE
00B2:  MOVFF  FAB,1B
00B6:  MOVFF  FAE,01
00BA:  BTFSS  1B.1
00BC:  BRA    00C2
00BE:  BCF    FAB.4
00C0:  BSF    FAB.4
00C2:  GOTO   00DE (RETURN)
.................... char buffer[4]; 
.................... int i = 0; 
.................... int16 diz, unit; 
.................... boolean flag = 0; 
.................... int16 lDist = 100; 
.................... int16 distance, time  ; 
.................... int d, c,u; 
....................  
.................... #int_RDA 
.................... void RDA_isr(void)  
.................... { 
....................    buffer[i] = getc(); 
00C6:  CLRF   03
00C8:  MOVF   20,W
00CA:  ADDLW  1C
00CC:  MOVWF  FE9
00CE:  MOVLW  00
00D0:  ADDWFC 03,W
00D2:  MOVWF  FEA
00D4:  MOVFF  FEA,3D
00D8:  MOVFF  FE9,3C
00DC:  BRA    00AE
00DE:  MOVFF  3D,FEA
00E2:  MOVFF  3C,FE9
00E6:  MOVFF  01,FEF
....................     if(buffer[0] == ':' && flag == 0 ){ 
00EA:  MOVF   1C,W
00EC:  SUBLW  3A
00EE:  BNZ   0100
00F0:  BTFSC  25.0
00F2:  BRA    0100
....................         i++; 
00F4:  INCF   20,F
....................         if(i>=4){ 
00F6:  MOVF   20,W
00F8:  SUBLW  03
00FA:  BC    0100
....................             i = 0; 
00FC:  CLRF   20
....................             flag = 1; 
00FE:  BSF    25.0
....................         } 
....................     } 
....................   
0100:  BCF    F9E.5
0102:  GOTO   0060
.................... } 
....................  
....................  
.................... void main() 
*
040C:  CLRF   FF8
040E:  BCF    FD0.7
0410:  BSF    07.7
0412:  CLRF   1B
0414:  MOVLW  81
0416:  MOVWF  FAF
0418:  MOVLW  A6
041A:  MOVWF  FAC
041C:  MOVLW  90
041E:  MOVWF  FAB
0420:  CLRF   20
0422:  BCF    25.0
0424:  CLRF   27
0426:  MOVLW  64
0428:  MOVWF  26
042A:  BSF    FC1.0
042C:  BSF    FC1.1
042E:  BSF    FC1.2
0430:  BCF    FC1.3
0432:  MOVLW  07
0434:  MOVWF  FB4
0436:  CLRF   19
0438:  CLRF   1A
.................... { 
....................  
....................    setup_adc_ports(NO_ANALOGS); 
043A:  BSF    FC1.0
043C:  BSF    FC1.1
043E:  BSF    FC1.2
0440:  BCF    FC1.3
....................    setup_adc(ADC_OFF); 
0442:  BCF    FC2.0
....................    setup_psp(PSP_DISABLED); 
0444:  BCF    F96.4
....................    setup_spi(FALSE); 
0446:  CLRF   FC6
....................    setup_wdt(WDT_OFF); 
0448:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
044A:  MOVLW  80
044C:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
044E:  MOVLW  B5
0450:  MOVWF  FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
0452:  MOVLW  00
0454:  MOVWF  FCA
0456:  MOVLW  00
0458:  MOVWF  FCB
....................    setup_comparator(NC_NC_NC_NC); 
045A:  MOVLW  07
045C:  MOVWF  FB4
045E:  MOVF   F95,W
0460:  MOVWF  F95
0462:  MOVF   F96,W
0464:  MOVWF  F96
0466:  MOVLW  10
0468:  MOVWF  00
046A:  DECFSZ 00,F
046C:  BRA    046A
046E:  NOP   
0470:  MOVF   FB4,W
0472:  BCF    FA1.6
....................    setup_vref(FALSE); 
0474:  CLRF   FB5
....................    enable_interrupts(INT_RDA); 
0476:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
0478:  MOVLW  C0
047A:  IORWF  FF2,F
....................    setup_oscillator(False); 
047C:  CLRF   FD3
....................     
....................    
....................      // TODO: USER CODE!! 
....................      while(true){ 
....................        
....................       //read value of sensor 
....................       output_high(pin_b1); 
047E:  BCF    F93.1
0480:  BSF    F8A.1
....................       delay_us(10); 
0482:  MOVLW  10
0484:  MOVWF  00
0486:  DECFSZ 00,F
0488:  BRA    0486
048A:  NOP   
....................       output_low(pin_c1); 
048C:  BCF    F94.1
048E:  BCF    F8B.1
....................        
....................       while(!input(pin_c0)){} //attendre l'etat haut de la pin echo 
0490:  BSF    F94.0
0492:  BTFSS  F82.0
0494:  BRA    0490
....................        
....................       set_timer1(0); 
0496:  CLRF   FCF
0498:  CLRF   FCE
....................        
....................       while(input(pin_c0)){} //attendre l'etat haut de la pin echo 
049A:  BSF    F94.0
049C:  BTFSC  F82.0
049E:  BRA    049A
....................       time = get_timer1();                
04A0:  MOVF   FCE,W
04A2:  MOVWF  2A
04A4:  MOVFF  FCF,2B
....................       distance = time*0.028;   
04A8:  MOVFF  2B,30
04AC:  MOVFF  2A,2F
04B0:  BRA    0118
04B2:  MOVFF  03,32
04B6:  MOVFF  02,31
04BA:  MOVFF  01,30
04BE:  MOVFF  00,2F
04C2:  MOVLW  42
04C4:  MOVWF  36
04C6:  MOVLW  60
04C8:  MOVWF  35
04CA:  MOVLW  65
04CC:  MOVWF  34
04CE:  MOVLW  79
04D0:  MOVWF  33
04D2:  BRA    0150
04D4:  MOVFF  03,32
04D8:  MOVFF  02,31
04DC:  MOVFF  01,30
04E0:  MOVFF  00,2F
04E4:  BRA    0244
04E6:  MOVFF  02,29
04EA:  MOVFF  01,28
....................       printf("distance : %ld \n" , distance); 
04EE:  MOVLW  06
04F0:  MOVWF  FF6
04F2:  MOVLW  01
04F4:  MOVWF  FF7
04F6:  MOVLW  0B
04F8:  MOVWF  2F
04FA:  BRA    027E
04FC:  MOVLW  10
04FE:  MOVWF  FE9
0500:  MOVFF  29,30
0504:  MOVFF  28,2F
0508:  BRA    02A0
050A:  MOVLW  20
050C:  BTFSS  F9E.4
050E:  BRA    050C
0510:  MOVWF  FAD
0512:  MOVLW  0A
0514:  BTFSS  F9E.4
0516:  BRA    0514
0518:  MOVWF  FAD
....................       printf("\n"); 
051A:  MOVLW  0A
051C:  BTFSS  F9E.4
051E:  BRA    051C
0520:  MOVWF  FAD
....................       delay_ms(100); 
0522:  MOVLW  64
0524:  MOVWF  2F
0526:  RCALL  0386
....................      
....................       if(distance<lDist){ 
0528:  MOVF   29,W
052A:  SUBWF  27,W
052C:  BNC   0540
052E:  BNZ   0536
0530:  MOVF   26,W
0532:  SUBWF  28,W
0534:  BC    0540
....................          output_high(PIN_E0); 
0536:  BCF    F96.0
0538:  BSF    F8D.0
....................          output_low(PIN_E1); 
053A:  BCF    F96.1
053C:  BCF    F8D.1
....................       }else{ 
053E:  BRA    0548
....................          output_low(PIN_E0); 
0540:  BCF    F96.0
0542:  BCF    F8D.0
....................          output_toggle(PIN_E1); 
0544:  BCF    F96.1
0546:  BTG    F8D.1
....................       } 
....................        
....................       if(distance<100){ 
0548:  MOVF   29,F
054A:  BNZ   05B2
054C:  MOVF   28,W
054E:  SUBLW  63
0550:  BNC   05B2
....................          output_low(pin_e2); 
0552:  BCF    F96.2
0554:  BCF    F8D.2
....................          unit = distance/10; 
0556:  MOVFF  29,32
055A:  MOVFF  28,31
055E:  CLRF   34
0560:  MOVLW  0A
0562:  MOVWF  33
0564:  RCALL  03AC
0566:  MOVFF  02,24
056A:  MOVFF  01,23
....................          diz = distance - (unit*10); 
056E:  MOVFF  24,30
0572:  MOVFF  23,2F
0576:  CLRF   32
0578:  MOVLW  0A
057A:  MOVWF  31
057C:  RCALL  03EE
057E:  MOVF   01,W
0580:  SUBWF  28,W
0582:  MOVWF  21
0584:  MOVF   02,W
0586:  SUBWFB 29,W
0588:  MOVWF  22
....................          output_b((diz<<4)+unit); 
058A:  RLCF   21,W
058C:  MOVWF  2F
058E:  RLCF   22,W
0590:  MOVWF  30
0592:  RLCF   2F,F
0594:  RLCF   30,F
0596:  RLCF   2F,F
0598:  RLCF   30,F
059A:  RLCF   2F,F
059C:  RLCF   30,F
059E:  MOVLW  F0
05A0:  ANDWF  2F,F
05A2:  MOVF   23,W
05A4:  ADDWF  2F,F
05A6:  MOVF   24,W
05A8:  ADDWFC 30,F
05AA:  CLRF   F93
05AC:  MOVFF  2F,F8A
....................       }else{ 
05B0:  BRA    061A
....................          output_high(PIN_E2); 
05B2:  BCF    F96.2
05B4:  BSF    F8D.2
....................          diz = distance/100; 
05B6:  MOVFF  29,32
05BA:  MOVFF  28,31
05BE:  CLRF   34
05C0:  MOVLW  64
05C2:  MOVWF  33
05C4:  RCALL  03AC
05C6:  MOVFF  02,22
05CA:  MOVFF  01,21
....................          unit = (distance - (diz*100))/10; 
05CE:  MOVFF  22,30
05D2:  MOVFF  21,2F
05D6:  CLRF   32
05D8:  MOVLW  64
05DA:  MOVWF  31
05DC:  RCALL  03EE
05DE:  MOVFF  02,03
05E2:  MOVF   01,W
05E4:  SUBWF  28,W
05E6:  MOVWF  2F
05E8:  MOVF   02,W
05EA:  SUBWFB 29,W
05EC:  MOVWF  30
05EE:  MOVWF  32
05F0:  MOVFF  2F,31
05F4:  CLRF   34
05F6:  MOVLW  0A
05F8:  MOVWF  33
05FA:  RCALL  03AC
05FC:  MOVFF  02,24
0600:  MOVFF  01,23
....................          output_b((diz<<0)+unit); 
0604:  MOVFF  22,30
0608:  MOVFF  21,2F
060C:  MOVF   23,W
060E:  ADDWF  2F,F
0610:  MOVF   24,W
0612:  ADDWFC 30,F
0614:  CLRF   F93
0616:  MOVFF  2F,F8A
....................           
....................          
....................       } 
....................        
....................       if(flag == 1){ 
061A:  BTFSS  25.0
061C:  BRA    0648
....................          flag =0; 
061E:  BCF    25.0
....................          c = buffer[1]-48; 
0620:  MOVLW  30
0622:  SUBWF  1D,W
0624:  MOVWF  2D
....................          d = buffer[2]-48; 
0626:  MOVLW  30
0628:  SUBWF  1E,W
062A:  MOVWF  2C
....................          u = buffer[3]-48; 
062C:  MOVLW  30
062E:  SUBWF  1F,W
0630:  MOVWF  2E
....................          lDist = (int16)(c*100+d*10+u); 
0632:  MOVF   2D,W
0634:  MULLW  64
0636:  MOVFF  FF3,2F
063A:  MOVF   2C,W
063C:  MULLW  0A
063E:  MOVF   FF3,W
0640:  ADDWF  2F,W
0642:  ADDWF  2E,W
0644:  CLRF   27
0646:  MOVWF  26
....................           
....................       } 
....................       c = lDist/100; 
0648:  MOVFF  27,32
064C:  MOVFF  26,31
0650:  CLRF   34
0652:  MOVLW  64
0654:  MOVWF  33
0656:  RCALL  03AC
0658:  MOVFF  01,2D
....................       d = (lDist-(c*100))/10; 
065C:  MOVF   2D,W
065E:  MULLW  64
0660:  MOVF   FF3,W
0662:  SUBWF  26,W
0664:  MOVWF  2F
0666:  MOVLW  00
0668:  SUBWFB 27,W
066A:  MOVWF  30
066C:  MOVWF  32
066E:  MOVFF  2F,31
0672:  CLRF   34
0674:  MOVLW  0A
0676:  MOVWF  33
0678:  RCALL  03AC
067A:  MOVFF  01,2C
....................       u = (lDist-(c*100))-(d*10); 
067E:  MOVF   2D,W
0680:  MULLW  64
0682:  MOVF   FF3,W
0684:  SUBWF  26,W
0686:  MOVWF  2F
0688:  MOVLW  00
068A:  SUBWFB 27,W
068C:  MOVF   2C,W
068E:  MULLW  0A
0690:  MOVF   FF3,W
0692:  SUBWF  2F,W
0694:  MOVWF  2E
....................       delay_ms(30); 
0696:  MOVLW  1E
0698:  MOVWF  2F
069A:  RCALL  0386
069C:  BRA    047E
....................      } 
....................  
.................... } 
....................  
069E:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   PUT NOBROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
