CCS PCH C Compiler, Version 5.025, 36897               17-mai-22 11:47

               Filename:   C:\Users\hakiz\OneDrive\Bureau\Haute Ecole Ephec\Bloc 2\Electronique Analogique\ProjetElectro\Electronique-digital-II\electro.lst

               ROM used:   1658 bytes (5%)
                           Largest free fragment is 31106
               RAM used:   47 (3%) at main() level
                           58 (4%) worst case
               Stack used: 2 locations (1 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   0406
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00BA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   00C4
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <electro.h> 
.................... #include <18F458.h> 
.................... //////////// Standard Header file for the PIC18F458 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F458 
*
00F6:  DATA 64,69
00F8:  DATA 73,74
00FA:  DATA 61,6E
00FC:  DATA 63,65
00FE:  DATA 20,65
0100:  DATA 73,74
0102:  DATA 20,65
0104:  DATA 67,61
0106:  DATA 6C,65
0108:  DATA 20,3A
010A:  DATA 20,25
010C:  DATA 6C,64
010E:  DATA 20,0A
0110:  DATA 00,00
0112:  MOVLW  8E
0114:  MOVWF  00
0116:  MOVFF  2E,01
011A:  MOVFF  2D,02
011E:  CLRF   03
0120:  MOVF   01,F
0122:  BNZ   0136
0124:  MOVFF  02,01
0128:  CLRF   02
012A:  MOVLW  08
012C:  SUBWF  00,F
012E:  MOVF   01,F
0130:  BNZ   0136
0132:  CLRF   00
0134:  BRA    0146
0136:  BCF    FD8.0
0138:  BTFSC  01.7
013A:  BRA    0144
013C:  RLCF   02,F
013E:  RLCF   01,F
0140:  DECF   00,F
0142:  BRA    0136
0144:  BCF    01.7
0146:  GOTO   04AA (RETURN)
014A:  MOVF   2D,W
014C:  BTFSC  FD8.2
014E:  BRA    0232
0150:  MOVWF  00
0152:  MOVF   31,W
0154:  BTFSC  FD8.2
0156:  BRA    0232
0158:  ADDWF  00,F
015A:  BNC   0164
015C:  MOVLW  81
015E:  ADDWF  00,F
0160:  BC    0232
0162:  BRA    016C
0164:  MOVLW  7F
0166:  SUBWF  00,F
0168:  BNC   0232
016A:  BZ    0232
016C:  MOVFF  2E,35
0170:  MOVF   32,W
0172:  XORWF  35,F
0174:  BSF    2E.7
0176:  BSF    32.7
0178:  MOVF   30,W
017A:  MULWF  34
017C:  MOVFF  FF4,37
0180:  MOVF   2F,W
0182:  MULWF  33
0184:  MOVFF  FF4,03
0188:  MOVFF  FF3,36
018C:  MULWF  34
018E:  MOVF   FF3,W
0190:  ADDWF  37,F
0192:  MOVF   FF4,W
0194:  ADDWFC 36,F
0196:  MOVLW  00
0198:  ADDWFC 03,F
019A:  MOVF   30,W
019C:  MULWF  33
019E:  MOVF   FF3,W
01A0:  ADDWF  37,F
01A2:  MOVF   FF4,W
01A4:  ADDWFC 36,F
01A6:  MOVLW  00
01A8:  CLRF   02
01AA:  ADDWFC 03,F
01AC:  ADDWFC 02,F
01AE:  MOVF   2E,W
01B0:  MULWF  34
01B2:  MOVF   FF3,W
01B4:  ADDWF  36,F
01B6:  MOVF   FF4,W
01B8:  ADDWFC 03,F
01BA:  MOVLW  00
01BC:  ADDWFC 02,F
01BE:  MOVF   2E,W
01C0:  MULWF  33
01C2:  MOVF   FF3,W
01C4:  ADDWF  03,F
01C6:  MOVF   FF4,W
01C8:  ADDWFC 02,F
01CA:  MOVLW  00
01CC:  CLRF   01
01CE:  ADDWFC 01,F
01D0:  MOVF   30,W
01D2:  MULWF  32
01D4:  MOVF   FF3,W
01D6:  ADDWF  36,F
01D8:  MOVF   FF4,W
01DA:  ADDWFC 03,F
01DC:  MOVLW  00
01DE:  ADDWFC 02,F
01E0:  ADDWFC 01,F
01E2:  MOVF   2F,W
01E4:  MULWF  32
01E6:  MOVF   FF3,W
01E8:  ADDWF  03,F
01EA:  MOVF   FF4,W
01EC:  ADDWFC 02,F
01EE:  MOVLW  00
01F0:  ADDWFC 01,F
01F2:  MOVF   2E,W
01F4:  MULWF  32
01F6:  MOVF   FF3,W
01F8:  ADDWF  02,F
01FA:  MOVF   FF4,W
01FC:  ADDWFC 01,F
01FE:  INCF   00,F
0200:  BTFSC  01.7
0202:  BRA    020E
0204:  RLCF   36,F
0206:  RLCF   03,F
0208:  RLCF   02,F
020A:  RLCF   01,F
020C:  DECF   00,F
020E:  MOVLW  00
0210:  BTFSS  36.7
0212:  BRA    0228
0214:  INCF   03,F
0216:  ADDWFC 02,F
0218:  ADDWFC 01,F
021A:  MOVF   01,W
021C:  BNZ   0228
021E:  MOVF   02,W
0220:  BNZ   0228
0222:  MOVF   03,W
0224:  BNZ   0228
0226:  INCF   00,F
0228:  BTFSC  35.7
022A:  BSF    01.7
022C:  BTFSS  35.7
022E:  BCF    01.7
0230:  BRA    023A
0232:  CLRF   00
0234:  CLRF   01
0236:  CLRF   02
0238:  CLRF   03
023A:  GOTO   04CC (RETURN)
023E:  MOVLW  8E
0240:  MOVWF  00
0242:  MOVF   2D,W
0244:  SUBWF  00,F
0246:  MOVFF  2E,02
024A:  MOVFF  2F,01
024E:  BSF    02.7
0250:  MOVF   00,F
0252:  BZ    0266
0254:  BCF    FD8.0
0256:  MOVF   02,F
0258:  BNZ   025E
025A:  MOVF   01,F
025C:  BZ    0266
025E:  RRCF   02,F
0260:  RRCF   01,F
0262:  DECFSZ 00,F
0264:  BRA    0254
0266:  BTFSS  2E.7
0268:  BRA    0274
026A:  COMF   01,F
026C:  COMF   02,F
026E:  INCF   01,F
0270:  BTFSC  FD8.2
0272:  INCF   02,F
0274:  GOTO   04DE (RETURN)
0278:  TBLRD*+
027A:  MOVFF  FF6,2E
027E:  MOVFF  FF7,2F
0282:  MOVF   FF5,W
0284:  BTFSS  F9E.4
0286:  BRA    0284
0288:  MOVWF  FAD
028A:  MOVFF  2E,FF6
028E:  MOVFF  2F,FF7
0292:  DECFSZ 2D,F
0294:  BRA    0278
0296:  GOTO   04F4 (RETURN)
029A:  MOVFF  FEA,35
029E:  MOVFF  FE9,34
02A2:  BTFSS  2E.7
02A4:  BRA    02B6
02A6:  BSF    34.7
02A8:  BTFSS  34.4
02AA:  INCF   34,F
02AC:  COMF   2D,F
02AE:  COMF   2E,F
02B0:  INCF   2D,F
02B2:  BTFSC  FD8.2
02B4:  INCF   2E,F
02B6:  SWAPF  2E,W
02B8:  IORLW  F0
02BA:  MOVWF  30
02BC:  ADDWF  30,F
02BE:  ADDLW  E2
02C0:  MOVWF  31
02C2:  ADDLW  32
02C4:  MOVWF  33
02C6:  MOVF   2E,W
02C8:  ANDLW  0F
02CA:  ADDWF  31,F
02CC:  ADDWF  31,F
02CE:  ADDWF  33,F
02D0:  ADDLW  E9
02D2:  MOVWF  32
02D4:  ADDWF  32,F
02D6:  ADDWF  32,F
02D8:  SWAPF  2D,W
02DA:  ANDLW  0F
02DC:  ADDWF  32,F
02DE:  ADDWF  33,F
02E0:  RLCF   32,F
02E2:  RLCF   33,F
02E4:  COMF   33,F
02E6:  RLCF   33,F
02E8:  MOVF   2D,W
02EA:  ANDLW  0F
02EC:  ADDWF  33,F
02EE:  RLCF   30,F
02F0:  MOVLW  07
02F2:  MOVWF  2F
02F4:  MOVLW  0A
02F6:  DECF   32,F
02F8:  ADDWF  33,F
02FA:  BNC   02F6
02FC:  DECF   31,F
02FE:  ADDWF  32,F
0300:  BNC   02FC
0302:  DECF   30,F
0304:  ADDWF  31,F
0306:  BNC   0302
0308:  DECF   2F,F
030A:  ADDWF  30,F
030C:  BNC   0308
030E:  CLRF   FEA
0310:  MOVLW  2F
0312:  MOVWF  FE9
0314:  MOVLW  07
0316:  ANDWF  34,W
0318:  BCF    34.6
031A:  MOVF   FED,F
031C:  ANDWF  34,W
031E:  BNZ   032E
0320:  BTFSC  34.4
0322:  MOVF   FEE,F
0324:  BTFSC  34.4
0326:  BRA    032E
0328:  MOVLW  20
032A:  MOVWF  00
032C:  BRA    036E
032E:  ADDWF  FE9,F
0330:  MOVLW  00
0332:  ADDWFC FEA,F
0334:  MOVF   FE9,W
0336:  SUBLW  33
0338:  BNZ   0340
033A:  MOVF   FEA,F
033C:  BNZ   0340
033E:  BSF    34.6
0340:  MOVF   FEF,W
0342:  MOVWF  00
0344:  BNZ   0356
0346:  BTFSC  34.6
0348:  BRA    0356
034A:  BTFSC  34.4
034C:  BRA    0376
034E:  BTFSC  34.3
0350:  BRA    0356
0352:  MOVLW  20
0354:  BRA    036C
0356:  BTFSS  34.7
0358:  BRA    0366
035A:  MOVLW  2D
035C:  MOVWF  00
035E:  MOVF   FED,W
0360:  BCF    34.6
0362:  BCF    34.7
0364:  BRA    036E
0366:  BSF    34.3
0368:  BCF    34.4
036A:  MOVLW  30
036C:  ADDWF  00,F
036E:  MOVF   00,W
0370:  BTFSS  F9E.4
0372:  BRA    0370
0374:  MOVWF  FAD
0376:  MOVF   FEE,W
0378:  BTFSS  34.6
037A:  BRA    0334
037C:  GOTO   0502 (RETURN)
*
03A6:  CLRF   01
03A8:  CLRF   02
03AA:  CLRF   00
03AC:  CLRF   03
03AE:  MOVF   32,W
03B0:  BNZ   03B6
03B2:  MOVF   31,W
03B4:  BZ    03E6
03B6:  MOVLW  10
03B8:  MOVWF  33
03BA:  BCF    FD8.0
03BC:  RLCF   2F,F
03BE:  RLCF   30,F
03C0:  RLCF   00,F
03C2:  RLCF   03,F
03C4:  MOVF   32,W
03C6:  SUBWF  03,W
03C8:  BNZ   03CE
03CA:  MOVF   31,W
03CC:  SUBWF  00,W
03CE:  BNC   03DE
03D0:  MOVF   31,W
03D2:  SUBWF  00,F
03D4:  BTFSS  FD8.0
03D6:  DECF   03,F
03D8:  MOVF   32,W
03DA:  SUBWF  03,F
03DC:  BSF    FD8.0
03DE:  RLCF   01,F
03E0:  RLCF   02,F
03E2:  DECFSZ 33,F
03E4:  BRA    03BA
03E6:  RETURN 0
03E8:  MOVF   2D,W
03EA:  MULWF  2F
03EC:  MOVFF  FF3,01
03F0:  MOVFF  FF4,00
03F4:  MULWF  30
03F6:  MOVF   FF3,W
03F8:  ADDWF  00,F
03FA:  MOVF   2E,W
03FC:  MULWF  2F
03FE:  MOVF   FF3,W
0400:  ADDWFC 00,W
0402:  MOVWF  02
0404:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES RC_IO                    //Resistor/Capacitor Osc 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOOSCSEN                 //Oscillator switching is disabled, main oscillator is source 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(clock=20000000) 
*
0380:  CLRF   FEA
0382:  MOVLW  2E
0384:  MOVWF  FE9
0386:  MOVF   FEF,W
0388:  BZ    03A4
038A:  MOVLW  06
038C:  MOVWF  01
038E:  CLRF   00
0390:  DECFSZ 00,F
0392:  BRA    0390
0394:  DECFSZ 01,F
0396:  BRA    038E
0398:  MOVLW  7B
039A:  MOVWF  00
039C:  DECFSZ 00,F
039E:  BRA    039C
03A0:  DECFSZ FEF,F
03A2:  BRA    038A
03A4:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................   
.................... char buffer[3]; 
.................... int i = 0; 
.................... int16 diz, unit; 
.................... boolean flag = 0; 
.................... int16 lDist = 100; 
.................... int16 distance, time  ; 
.................... int d, c,u; 
....................  
.................... #INT_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    set_timer1(0); 
*
00BA:  CLRF   FCF
00BC:  CLRF   FCE
....................  
....................  
.................... } 
00BE:  BCF    F9E.0
00C0:  GOTO   006C
.................... #int_RDA 
.................... void RDA_isr(void)  
.................... { 
....................    buffer[i] = getc(); 
00C4:  CLRF   03
00C6:  MOVF   1E,W
00C8:  ADDLW  1B
00CA:  MOVWF  FE9
00CC:  MOVLW  00
00CE:  ADDWFC 03,W
00D0:  MOVWF  FEA
00D2:  BTFSS  F9E.5
00D4:  BRA    00D2
00D6:  MOVFF  FAE,FEF
....................     if(buffer[0] == ':' && flag == 0 ){ 
00DA:  MOVF   1B,W
00DC:  SUBLW  3A
00DE:  BNZ   00F0
00E0:  BTFSC  23.0
00E2:  BRA    00F0
....................         i++; 
00E4:  INCF   1E,F
....................         if(i>4){ 
00E6:  MOVF   1E,W
00E8:  SUBLW  04
00EA:  BC    00F0
....................             i = 0; 
00EC:  CLRF   1E
....................             flag = 1; 
00EE:  BSF    23.0
....................         } 
....................     } 
....................   
00F0:  BCF    F9E.5
00F2:  GOTO   006C
.................... } 
....................  
....................  
.................... void main() 
*
0406:  CLRF   FF8
0408:  BCF    FD0.7
040A:  BSF    07.7
040C:  MOVLW  81
040E:  MOVWF  FAF
0410:  MOVLW  A6
0412:  MOVWF  FAC
0414:  MOVLW  90
0416:  MOVWF  FAB
0418:  CLRF   1E
041A:  BCF    23.0
041C:  CLRF   25
041E:  MOVLW  64
0420:  MOVWF  24
0422:  BSF    FC1.0
0424:  BSF    FC1.1
0426:  BSF    FC1.2
0428:  BCF    FC1.3
042A:  MOVLW  07
042C:  MOVWF  FB4
042E:  CLRF   19
0430:  CLRF   1A
.................... { 
....................  
....................    setup_adc_ports(NO_ANALOGS); 
0432:  BSF    FC1.0
0434:  BSF    FC1.1
0436:  BSF    FC1.2
0438:  BCF    FC1.3
....................    setup_adc(ADC_OFF); 
043A:  BCF    FC2.0
....................    setup_psp(PSP_DISABLED); 
043C:  BCF    F96.4
....................    setup_spi(FALSE); 
043E:  CLRF   FC6
....................    setup_wdt(WDT_OFF); 
0440:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
0442:  MOVLW  80
0444:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0446:  MOVLW  B5
0448:  MOVWF  FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
044A:  MOVLW  00
044C:  MOVWF  FCA
044E:  MOVLW  00
0450:  MOVWF  FCB
....................    setup_comparator(NC_NC_NC_NC); 
0452:  MOVLW  07
0454:  MOVWF  FB4
0456:  MOVF   F95,W
0458:  MOVWF  F95
045A:  MOVF   F96,W
045C:  MOVWF  F96
045E:  MOVLW  10
0460:  MOVWF  00
0462:  DECFSZ 00,F
0464:  BRA    0462
0466:  NOP   
0468:  MOVF   FB4,W
046A:  BCF    FA1.6
....................    setup_vref(FALSE); 
046C:  CLRF   FB5
....................    enable_interrupts(INT_RDA); 
046E:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
0470:  MOVLW  C0
0472:  IORWF  FF2,F
....................    setup_oscillator(False); 
0474:  CLRF   FD3
....................     
....................    
....................      // TODO: USER CODE!! 
....................      while(true){ 
....................        
....................       //read value of sensor 
....................       output_high(pin_c1); 
0476:  BCF    F94.1
0478:  BSF    F8B.1
....................       delay_us(100); 
047A:  MOVLW  A6
047C:  MOVWF  00
047E:  DECFSZ 00,F
0480:  BRA    047E
0482:  NOP   
....................       output_low(pin_c1); 
0484:  BCF    F94.1
0486:  BCF    F8B.1
....................        
....................       while(!input(pin_c0)){} //attendre l'etat haut de la pin echo 
0488:  BSF    F94.0
048A:  BTFSS  F82.0
048C:  BRA    0488
....................        
....................       set_timer1(0); 
048E:  CLRF   FCF
0490:  CLRF   FCE
....................        
....................       while(input(pin_c0)){} //attendre l'etat haut de la pin echo 
0492:  BSF    F94.0
0494:  BTFSC  F82.0
0496:  BRA    0492
....................       time = get_timer1();                
0498:  MOVF   FCE,W
049A:  MOVWF  28
049C:  MOVFF  FCF,29
....................       distance = time*0.028;  
04A0:  MOVFF  29,2E
04A4:  MOVFF  28,2D
04A8:  BRA    0112
04AA:  MOVFF  03,30
04AE:  MOVFF  02,2F
04B2:  MOVFF  01,2E
04B6:  MOVFF  00,2D
04BA:  MOVLW  42
04BC:  MOVWF  34
04BE:  MOVLW  60
04C0:  MOVWF  33
04C2:  MOVLW  65
04C4:  MOVWF  32
04C6:  MOVLW  79
04C8:  MOVWF  31
04CA:  BRA    014A
04CC:  MOVFF  03,30
04D0:  MOVFF  02,2F
04D4:  MOVFF  01,2E
04D8:  MOVFF  00,2D
04DC:  BRA    023E
04DE:  MOVFF  02,27
04E2:  MOVFF  01,26
....................       printf("distance est egale : %ld \n" , distance); 
04E6:  MOVLW  F6
04E8:  MOVWF  FF6
04EA:  MOVLW  00
04EC:  MOVWF  FF7
04EE:  MOVLW  15
04F0:  MOVWF  2D
04F2:  BRA    0278
04F4:  MOVLW  10
04F6:  MOVWF  FE9
04F8:  MOVFF  27,2E
04FC:  MOVFF  26,2D
0500:  BRA    029A
0502:  MOVLW  20
0504:  BTFSS  F9E.4
0506:  BRA    0504
0508:  MOVWF  FAD
050A:  MOVLW  0A
050C:  BTFSS  F9E.4
050E:  BRA    050C
0510:  MOVWF  FAD
....................       printf("\n"); 
0512:  MOVLW  0A
0514:  BTFSS  F9E.4
0516:  BRA    0514
0518:  MOVWF  FAD
....................       delay_ms(100); 
051A:  MOVLW  64
051C:  MOVWF  2E
051E:  RCALL  0380
....................      
....................       if(distance<lDist){ 
0520:  MOVF   27,W
0522:  SUBWF  25,W
0524:  BNC   0538
0526:  BNZ   052E
0528:  MOVF   24,W
052A:  SUBWF  26,W
052C:  BC    0538
....................          output_high(PIN_E0); 
052E:  BCF    F96.0
0530:  BSF    F8D.0
....................          output_low(PIN_E1); 
0532:  BCF    F96.1
0534:  BCF    F8D.1
....................       }else{ 
0536:  BRA    0540
....................          output_low(PIN_E0); 
0538:  BCF    F96.0
053A:  BCF    F8D.0
....................          output_toggle(PIN_E1); 
053C:  BCF    F96.1
053E:  BTG    F8D.1
....................       } 
....................        
....................       if(distance < 100){ 
0540:  MOVF   27,F
0542:  BNZ   05AA
0544:  MOVF   26,W
0546:  SUBLW  63
0548:  BNC   05AA
....................         output_low(PIN_E2); 
054A:  BCF    F96.2
054C:  BCF    F8D.2
....................         diz = distance/10; 
054E:  MOVFF  27,30
0552:  MOVFF  26,2F
0556:  CLRF   32
0558:  MOVLW  0A
055A:  MOVWF  31
055C:  RCALL  03A6
055E:  MOVFF  02,20
0562:  MOVFF  01,1F
....................         unit = distance - (diz*10); 
0566:  MOVFF  20,2E
056A:  MOVFF  1F,2D
056E:  CLRF   30
0570:  MOVLW  0A
0572:  MOVWF  2F
0574:  RCALL  03E8
0576:  MOVF   01,W
0578:  SUBWF  26,W
057A:  MOVWF  21
057C:  MOVF   02,W
057E:  SUBWFB 27,W
0580:  MOVWF  22
....................         output_b((diz<<4)+unit); 
0582:  RLCF   1F,W
0584:  MOVWF  2D
0586:  RLCF   20,W
0588:  MOVWF  2E
058A:  RLCF   2D,F
058C:  RLCF   2E,F
058E:  RLCF   2D,F
0590:  RLCF   2E,F
0592:  RLCF   2D,F
0594:  RLCF   2E,F
0596:  MOVLW  F0
0598:  ANDWF  2D,F
059A:  MOVF   21,W
059C:  ADDWF  2D,F
059E:  MOVF   22,W
05A0:  ADDWFC 2E,F
05A2:  CLRF   F93
05A4:  MOVFF  2D,F8A
....................     }else{ 
05A8:  BRA    063E
....................         output_high(PIN_E2); 
05AA:  BCF    F96.2
05AC:  BSF    F8D.2
....................         diz = distance/100; 
05AE:  MOVFF  27,30
05B2:  MOVFF  26,2F
05B6:  CLRF   32
05B8:  MOVLW  64
05BA:  MOVWF  31
05BC:  RCALL  03A6
05BE:  MOVFF  02,20
05C2:  MOVFF  01,1F
....................         output_high(PIN_E2); 
05C6:  BCF    F96.2
05C8:  BSF    F8D.2
....................         diz = distance/100; 
05CA:  MOVFF  27,30
05CE:  MOVFF  26,2F
05D2:  CLRF   32
05D4:  MOVLW  64
05D6:  MOVWF  31
05D8:  RCALL  03A6
05DA:  MOVFF  02,20
05DE:  MOVFF  01,1F
....................         unit = (distance - (diz*100))/10; 
05E2:  MOVFF  20,2E
05E6:  MOVFF  1F,2D
05EA:  CLRF   30
05EC:  MOVLW  64
05EE:  MOVWF  2F
05F0:  RCALL  03E8
05F2:  MOVFF  02,03
05F6:  MOVF   01,W
05F8:  SUBWF  26,W
05FA:  MOVWF  2D
05FC:  MOVF   02,W
05FE:  SUBWFB 27,W
0600:  MOVWF  2E
0602:  MOVWF  30
0604:  MOVFF  2D,2F
0608:  CLRF   32
060A:  MOVLW  0A
060C:  MOVWF  31
060E:  RCALL  03A6
0610:  MOVFF  02,22
0614:  MOVFF  01,21
....................         output_b((diz<<4)+unit); 
0618:  RLCF   1F,W
061A:  MOVWF  2D
061C:  RLCF   20,W
061E:  MOVWF  2E
0620:  RLCF   2D,F
0622:  RLCF   2E,F
0624:  RLCF   2D,F
0626:  RLCF   2E,F
0628:  RLCF   2D,F
062A:  RLCF   2E,F
062C:  MOVLW  F0
062E:  ANDWF  2D,F
0630:  MOVF   21,W
0632:  ADDWF  2D,F
0634:  MOVF   22,W
0636:  ADDWFC 2E,F
0638:  CLRF   F93
063A:  MOVFF  2D,F8A
....................     } 
....................        
....................       if(flag == 1){ 
063E:  BTFSS  23.0
0640:  BRA    066C
....................          flag =0; 
0642:  BCF    23.0
....................          c = buffer[1]-48; 
0644:  MOVLW  30
0646:  SUBWF  1C,W
0648:  MOVWF  2B
....................          d = buffer[2]-48; 
064A:  MOVLW  30
064C:  SUBWF  1D,W
064E:  MOVWF  2A
....................          u = buffer[3]-48; 
0650:  MOVLW  30
0652:  SUBWF  1E,W
0654:  MOVWF  2C
....................          lDist = (int16)(c*100+d*10+u); 
0656:  MOVF   2B,W
0658:  MULLW  64
065A:  MOVFF  FF3,2D
065E:  MOVF   2A,W
0660:  MULLW  0A
0662:  MOVF   FF3,W
0664:  ADDWF  2D,W
0666:  ADDWF  2C,W
0668:  CLRF   25
066A:  MOVWF  24
....................           
....................       } 
....................       delay_ms(300); 
066C:  MOVLW  02
066E:  MOVWF  2D
0670:  MOVLW  96
0672:  MOVWF  2E
0674:  RCALL  0380
0676:  DECFSZ 2D,F
0678:  BRA    0670
067A:  BRA    0476
....................      } 
....................  
.................... } 
....................  
067C:  SLEEP 

Configuration Fuses:
   Word  1: 2700   RC_IO NOOSCSEN
   Word  2: 0E0F   NOPUT BROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0085   STVREN LVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
